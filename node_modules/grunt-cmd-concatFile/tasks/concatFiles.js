var path = require('path');

module.exports = function (grunt) {

    var ast = require('cmd-util').ast;
    var iduri = require('cmd-util').iduri;
    var detectDestType = function (dest) {
        if (grunt.util._.endsWith(dest, '/')) {
            return 'directory';
        } else {
            return 'file';
        }
    };

    var unixifyPath = function (filepath) {
        if (process.platform === 'win32') {
            return filepath.replace(/\\/g, '/');
        } else {
            return filepath;
        }
    };
    var findFiles = function (filepath, options) {
        var data = grunt.file.read(filepath);
        var meta = ast.parseFirst(data);
        var records = grunt.option('concat-records');
        if (grunt.util._.contains(records, meta.id)) {
            return '';
        }
        records.push(meta.id);
        if (options.include === 'self') {
            return data;
        }

        var concatImg = [];
        var files = [];
        var targDir = path.join(path.dirname(filepath), options.srcFiles);
        concatImg.push(targDir);

        meta.dependencies.forEach(function (dep) {
            if (dep.charAt(0) === '.') {
                var id = iduri.absolute(meta.id, dep);
                if (grunt.util._.contains(records, id)) {
                    return '';
                }
                records.push(id);

                var srcDir = path.join(path.dirname(iduri.absolute(filepath, dep)), options.distFiles);
                if (grunt.util._.contains(concatImg, srcDir)) {
                    return '';
                }
                concatImg.push(srcDir);
                files.push({
                    cwd: srcDir,
                    src: "**/*.*",
                    dest: targDir,
                    expand: true
                });
            }
        });
        handleFiles(files);
    };
    var handleFiles = function (files) {
        files = grunt.util._(files).chain().forEach(function (obj) {
            if (!('src' in obj) || !obj.src) {
                return;
            }
            // Normalize .src properties to flattened array.
            if (Array.isArray(obj.src)) {
                obj.src = grunt.util._.flatten(obj.src);
            } else {
                obj.src = [obj.src];
            }
        }).map(function (obj) {
            // Build options object, removing unwanted properties.
            var expandOptions = grunt.util._.extend({}, obj);
            delete expandOptions.src;
            delete expandOptions.dest;

            // Expand file mappings.
            if (obj.expand) {
                return grunt.file.expandMapping(obj.src, obj.dest, expandOptions).map(function (mapObj) {
                    // Copy obj properties to result.
                    var result = grunt.util._.extend({}, obj);
                    // Make a clone of the orig obj available.
                    result.orig = grunt.util._.extend({}, obj);
                    // Set .src and .dest, processing both as templates.
                    result.src = grunt.config.process(mapObj.src);
                    result.dest = grunt.config.process(mapObj.dest);
                    // Remove unwanted properties.
                    ['expand', 'cwd', 'flatten', 'rename', 'ext'].forEach(function (prop) {
                        delete result[prop];
                    });
                    return result;
                });
            }
        }).flatten().value();
        copyFiles(files);
    };

    var copyFiles = function (files) {
        files.forEach(function (filePair) {
            var isExpandedPair = filePair.orig.expand || false;

            filePair.src.forEach(function (src) {
                var dest;
                if (detectDestType(filePair.dest) === 'directory') {
                    dest = (isExpandedPair) ? filePair.dest : unixifyPath(path.join(filePair.dest, src));
                } else {
                    dest = filePair.dest;
                }

                if (grunt.file.isDir(src)) {
                    grunt.verbose.writeln('Creating ' + dest.cyan);
                    grunt.file.mkdir(dest);
                } else {
                    grunt.verbose.writeln('Copying ' + src.cyan + ' -> ' + dest.cyan);
                    grunt.file.copy(src, dest, {
                        process: false,
                        noProcess: []
                    });
                }
            });
        });
    };
    grunt.registerMultiTask('concatFiles', 'concat cmd modules.', function () {
        // Merge task-specific and/or target-specific options with these defaults.
        var options = this.options({
            paths: ['sea-modules'],
            include: 'self',
            srcFiles: 'imgs',
            distFiles: 'imgs'
        });

        this.files.forEach(function (f) {
            // reset records
            grunt.option('concat-records', []);

            // Concat specified files.
            f.src.filter(function (filepath) {
                // Warn on and remove invalid source files (if nonull was set).
                if (!grunt.file.exists(filepath)) {
                    grunt.log.warn('Source file "' + filepath + '" not found.');
                    return false;
                } else {
                    return true;
                }
            });
            f.src.map(function (filepath) {
                var extname = path.extname(filepath);
                if (extname != '.js')
                    return;
                findFiles(filepath, options);
            });
        });
    });
}
