var path = require('path');

module.exports = function (grunt) {
    var ast = require('cmd-util').ast;
    var iduri = require('cmd-util').iduri;
    var findFiles = function (filepath, options,dest) {
        var data = grunt.file.read(filepath);
        var meta = ast.parseFirst(data);
        var records = grunt.option('concat-records');
        if (grunt.util._.contains(records, meta.id)) {
            return '';
        }
        records.push(meta.id);
        if (options.include === 'self') {
            return data;
        }

        var targCss,srcCss = [],temp;

        meta.dependencies.forEach(function (dep) {
            if (dep.charAt(0) === '.') {
                var id = iduri.absolute(meta.id, dep);
                if (grunt.util._.contains(records, id)) {
                    return '';
                }
                records.push(id);

                var filePath = iduri.absolute(filepath, dep);
                var supDir = path.dirname(filePath);
                if(/\.css$/.test(dep)){
                    if(!targCss && supDir == path.dirname(filepath)){
                        targCss =  path.dirname(dest) + '/' +/.*\/(.+?\.css)/.exec(dep)[1];
                        temp = path.dirname(filepath) + '/' +/.*\/(.+?\.css)/.exec(dep)[1]
                    }
                    if(!grunt.util._.contains(srcCss, filePath)){
                        srcCss.push(filePath);
                    }
                }
            }
        });

        if(!targCss){
            targCss =  /(.+?)\.js$/.exec(dest)[1] + '.css';
            temp =  /(.+?)\.js$/.exec(filepath)[1] + '.css';
        }
        if(grunt.file.exists(temp)){
            srcCss.push(temp);
        }
        srcCss.length && handleFiles({
            src: srcCss,
            dest: targCss
        },'dest',options);


        meta.dependencies.forEach(function (dep) {
            if (dep.charAt(0) === '.') {
                var fpath = path.join(path.dirname(filepath), dep);
                if (!/\.js$/.test(fpath)) fpath += '.js';
                if (!grunt.file.exists(fpath)) {
                    if (!/\{\w+\}/.test(fpath)) {
                        grunt.log.warn('file ' + fpath + ' not found');
                    }
                    return '';
                }

                var astCache = ast.getAst(grunt.file.read(fpath));
                var srcId = ast.parseFirst(astCache).id;
                astCache = ast.modify(astCache, function (v) {
                    if(v.charAt(0) === '.' && /\.css$/.test(v)){
                        //return  targCss;
                        //return path.relative('.build/' + iduri.absolute(srcId, v),temp).replace(/\\/g,'/');
                        return temp.replace(/\.build\//g,'');
                    }
                    if (v.charAt(0) === '.') {
                        return iduri.absolute(srcId, v);
                    }
                    return v;
                });
                grunt.file.write(fpath, astCache.print_to_string(options.uglify));
            }
        });


    };
    var handleFiles = function (data,target,options) {
        var prop, obj;
        var files = [];
        if (grunt.util.kindOf(data) === 'object') {
            if ('src' in data || 'dest' in data) {
                obj = {};
                for (prop in data) {
                    if (prop !== 'options') {
                        obj[prop] = data[prop];
                    }
                }
                files.push(obj);
            } else if (grunt.util.kindOf(data.files) === 'object') {
                for (prop in data.files) {
                    files.push({src: data.files[prop], dest: grunt.config.process(prop)});
                }
            } else if (Array.isArray(data.files)) {
                grunt.util._.flatten(data.files).forEach(function(obj) {
                    var prop;
                    if ('src' in obj || 'dest' in obj) {
                        files.push(obj);
                    } else {
                        for (prop in obj) {
                            files.push({src: obj[prop], dest: grunt.config.process(prop)});
                        }
                    }
                });
            }
        } else {
            files.push({src: data, dest: grunt.config.process(target)});
        }

        // If no src/dest or files were specified, return an empty files array.
        if (files.length === 0) {
            grunt.verbose.writeln('File: ' + '[no files]'.yellow);
            return [];
        }
        files = grunt.util._(files).chain().forEach(function (obj) {
            if (!('src' in obj) || !obj.src) {
                return;
            }
            // Normalize .src properties to flattened array.
            if (Array.isArray(obj.src)) {
                obj.src = grunt.util._.flatten(obj.src);
            } else {
                obj.src = [obj.src];
            }
        }).map(function (obj) {
            // Build options object, removing unwanted properties.
            var expandOptions = grunt.util._.extend({}, obj);
            delete expandOptions.src;
            delete expandOptions.dest;

            // Expand file mappings.
            if (obj.expand) {
                return grunt.file.expandMapping(obj.src, obj.dest, expandOptions).map(function (mapObj) {
                    // Copy obj properties to result.
                    var result = grunt.util._.extend({}, obj);
                    // Make a clone of the orig obj available.
                    result.orig = grunt.util._.extend({}, obj);
                    // Set .src and .dest, processing both as templates.
                    result.src = grunt.config.process(mapObj.src);
                    result.dest = grunt.config.process(mapObj.dest);
                    // Remove unwanted properties.
                    ['expand', 'cwd', 'flatten', 'rename', 'ext'].forEach(function (prop) {
                        delete result[prop];
                    });
                    return result;
                });
            }
            // Copy obj properties to result, adding an .orig property.
            var result = grunt.util._.extend({}, obj);
            // Make a clone of the orig obj available.
            result.orig = grunt.util._.extend({}, obj);

            if ('src' in result) {
                // Expose an expand-on-demand getter method as .src.
                Object.defineProperty(result, 'src', {
                    enumerable: true,
                    get: function fn() {
                        var src;
                        if (!('result' in fn)) {
                            src = obj.src;
                            // If src is an array, flatten it. Otherwise, make it into an array.
                            src = Array.isArray(src) ? grunt.util._.flatten(src) : [src];
                            // Expand src files, memoizing result.
                            fn.result = grunt.file.expand(expandOptions, src);
                        }
                        return fn.result;
                    }
                });
            }

            if ('dest' in result) {
                result.dest = obj.dest;
            }

            return result;
        }).flatten().value();
        copyFiles(files,options);
    };

    var copyFiles = function (files,options) {
        // Iterate over all src-dest file pairs.
        files.forEach(function(f) {
            // Concat banner + specified files + footer.
            var src = f.src.filter(function(filepath) {
                // Warn on and remove invalid source files (if nonull was set).
                if (!grunt.file.exists(filepath)) {
                    grunt.log.warn('Source file "' + filepath + '" not found.');
                    return false;
                } else {
                    return true;
                }
            }).map(function(filepath) {
                // Read file source.
                var src = grunt.file.read(filepath);
                return src;
            }).join(options.separator);

            // Write the destination file.
            grunt.file.write(f.dest, src);

            // Print a success message.
            //grunt.log.writeln('File ' + chalk.cyan(f.dest) + ' created.');
        });
    };
    grunt.registerMultiTask('concatCss', 'concat cmd modules.', function () {
        // Merge task-specific and/or target-specific options with these defaults.
        var options = this.options({
            paths: ['sea-modules'],
            include: 'self',
            uglify: {
                beautify: true,
                comments: true
            },
            separator: grunt.util.linefeed
        });

        this.files.forEach(function (f) {
            // reset records
            grunt.option('concat-records', []);

            // Concat specified files.
            f.src.filter(function (filepath) {
                // Warn on and remove invalid source files (if nonull was set).
                if (!grunt.file.exists(filepath)) {
                    grunt.log.warn('Source file "' + filepath + '" not found.');
                    return false;
                } else {
                    return true;
                }
            });
            f.src.map(function (filepath) {
                var extname = path.extname(filepath);
                if (extname != '.js')
                    return;
                findFiles(filepath, options, f.dest);
            });
        });
    });
}
